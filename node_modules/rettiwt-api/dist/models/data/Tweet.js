"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweetMedia = exports.TweetEntities = exports.Tweet = void 0;
const Logging_1 = require("../../enums/Logging");
const Media_1 = require("../../enums/Media");
const Media_2 = require("../../enums/raw/Media");
const JsonUtils_1 = require("../../helper/JsonUtils");
const LogService_1 = require("../../services/internal/LogService");
const User_1 = require("./User");
/**
 * The details of a single tweet.
 *
 * @public
 */
class Tweet {
    /** The raw tweet details. */
    _raw;
    bookmarkCount;
    conversationId;
    createdAt;
    entities;
    fullText;
    id;
    lang;
    likeCount;
    media;
    quoteCount;
    quoted;
    replyCount;
    replyTo;
    retweetCount;
    retweetedTweet;
    tweetBy;
    url;
    viewCount;
    /**
     * @param tweet - The raw tweet details.
     */
    constructor(tweet) {
        this._raw = { ...tweet };
        this.id = tweet.rest_id;
        this.conversationId = tweet.legacy.conversation_id_str;
        this.createdAt = new Date(tweet.legacy.created_at).toISOString();
        this.tweetBy = new User_1.User(tweet.core.user_results.result);
        this.entities = new TweetEntities(tweet.legacy.entities);
        this.media = tweet.legacy.extended_entities?.media?.map((media) => new TweetMedia(media));
        this.quoted = this._getQuotedTweet(tweet);
        this.fullText = tweet.note_tweet ? tweet.note_tweet.note_tweet_results.result.text : tweet.legacy.full_text;
        this.replyTo = tweet.legacy.in_reply_to_status_id_str;
        this.lang = tweet.legacy.lang;
        this.quoteCount = tweet.legacy.quote_count;
        this.replyCount = tweet.legacy.reply_count;
        this.retweetCount = tweet.legacy.retweet_count;
        this.likeCount = tweet.legacy.favorite_count;
        this.viewCount = tweet.views.count ? parseInt(tweet.views.count) : 0;
        this.bookmarkCount = tweet.legacy.bookmark_count;
        this.retweetedTweet = this._getRetweetedTweet(tweet);
        this.url = `https://x.com/${this.tweetBy.userName}/status/${this.id}`;
    }
    /** The raw tweet details. */
    get raw() {
        return { ...this._raw };
    }
    /**
     * Extract and deserialize the original quoted tweet from the given raw tweet.
     *
     * @param tweet - The raw tweet.
     *
     * @returns - The deserialized original quoted tweet.
     */
    _getQuotedTweet(tweet) {
        // If tweet with limited visibility
        if (tweet.quoted_status_result &&
            tweet.quoted_status_result?.result?.__typename == 'TweetWithVisibilityResults' &&
            tweet.quoted_status_result.result?.tweet?.legacy) {
            return new Tweet(tweet.quoted_status_result.result.tweet);
        }
        // If normal tweet
        else if (tweet.quoted_status_result?.result?.rest_id) {
            return new Tweet(tweet.quoted_status_result.result);
        }
        // Else, skip
        else {
            return undefined;
        }
    }
    /**
     * Extract and deserialize the original retweeted tweet from the given raw tweet.
     *
     * @param tweet - The raw tweet.
     *
     * @returns - The deserialized original retweeted tweet.
     */
    _getRetweetedTweet(tweet) {
        // If retweet with limited visibility
        if (tweet.legacy?.retweeted_status_result &&
            tweet.legacy?.retweeted_status_result?.result?.__typename == 'TweetWithVisibilityResults' &&
            tweet.legacy?.retweeted_status_result?.result?.tweet?.legacy) {
            return new Tweet(tweet.legacy.retweeted_status_result.result.tweet);
        }
        // If normal tweet
        else if (tweet.legacy?.retweeted_status_result?.result?.rest_id) {
            return new Tweet(tweet.legacy.retweeted_status_result.result);
        }
        // Else, skip
        else {
            return undefined;
        }
    }
    /**
     * Extracts and deserializes multiple target tweets from the given raw response data.
     *
     * @param response - The raw response data.
     * @param ids - The ids of the target tweets.
     *
     * @returns The target deserialized tweets.
     */
    static multiple(response, ids) {
        let tweets = [];
        // Extracting the matching data
        const extract = (0, JsonUtils_1.findByFilter)(response, '__typename', 'Tweet');
        // Deserializing valid data
        for (const item of extract) {
            if (item.legacy) {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.DESERIALIZE, { id: item.rest_id });
                tweets.push(new Tweet(item));
            }
            else {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.WARNING, {
                    action: Logging_1.LogActions.DESERIALIZE,
                    message: `Tweet not found, skipping`,
                });
            }
        }
        // Filtering only required tweets, if required
        if (ids && ids.length) {
            tweets = tweets.filter((tweet) => ids.includes(tweet.id));
        }
        return tweets;
    }
    /**
     * Extracts and deserializes a single target tweet from the given raw response data.
     *
     * @param response - The raw response data.
     * @param id - The id of the target tweet.
     *
     * @returns The target deserialized tweet.
     */
    static single(response, id) {
        const tweets = [];
        // Extracting the matching data
        const extract = (0, JsonUtils_1.findByFilter)(response, 'rest_id', id);
        // Deserializing valid data
        for (const item of extract) {
            if (item.legacy) {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.DESERIALIZE, { id: item.rest_id });
                tweets.push(new Tweet(item));
            }
            else {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.WARNING, {
                    action: Logging_1.LogActions.DESERIALIZE,
                    message: `Tweet not found, skipping`,
                });
            }
        }
        return tweets.length ? tweets[0] : undefined;
    }
    /**
     * Extracts and deserializes the timeline of tweets from the given raw response data.
     *
     * @param response - The raw response data.
     * @param ids - The IDs of specific tweets that need to be extracted.
     *
     * @returns The deserialized timeline of tweets.
     */
    static timeline(response) {
        const tweets = [];
        // Extracting the matching data
        const extract = (0, JsonUtils_1.findByFilter)(response, '__typename', 'TimelineTweet');
        // Deserializing valid data
        for (const item of extract) {
            // If tweet with limited visibility
            if (item.tweet_results?.result &&
                item.tweet_results?.result?.__typename == 'TweetWithVisibilityResults' &&
                item.tweet_results?.result?.tweet?.legacy) {
                tweets.push(new Tweet(item.tweet_results.result.tweet));
            }
            // If normal tweet
            else if (item.tweet_results?.result?.legacy) {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.DESERIALIZE, { id: item.tweet_results.result.rest_id });
                tweets.push(new Tweet(item.tweet_results.result));
            }
            // If invalid/unrecognized tweet
            else {
                // Logging
                LogService_1.LogService.log(Logging_1.LogActions.WARNING, {
                    action: Logging_1.LogActions.DESERIALIZE,
                    message: `Tweet not found, skipping`,
                });
            }
        }
        return tweets;
    }
    /**
     * @returns A serializable JSON representation of `this` object.
     */
    toJSON() {
        return {
            bookmarkCount: this.bookmarkCount,
            conversationId: this.conversationId,
            createdAt: this.createdAt,
            entities: this.entities.toJSON(),
            fullText: this.fullText,
            id: this.id,
            lang: this.lang,
            likeCount: this.likeCount,
            media: this.media?.map((item) => item.toJSON()),
            quoteCount: this.quoteCount,
            quoted: this.quoted?.toJSON(),
            replyCount: this.replyCount,
            replyTo: this.replyTo,
            retweetCount: this.retweetCount,
            retweetedTweet: this.retweetedTweet?.toJSON(),
            tweetBy: this.tweetBy.toJSON(),
            url: this.url,
            viewCount: this.viewCount,
        };
    }
}
exports.Tweet = Tweet;
/**
 * The different types parsed entities like urls, media, mentions, hashtags, etc.
 *
 * @public
 */
class TweetEntities {
    /** The list of hashtags mentioned in the tweet. */
    hashtags = [];
    /** The list of IDs of users mentioned in the tweet. */
    mentionedUsers = [];
    /** The list of urls mentioned in the tweet. */
    urls = [];
    /**
     * @param entities - The raw tweet entities.
     */
    constructor(entities) {
        // Extracting user mentions
        if (entities.user_mentions) {
            for (const user of entities.user_mentions) {
                this.mentionedUsers.push(user.screen_name);
            }
        }
        // Extracting urls
        if (entities.urls) {
            for (const url of entities.urls) {
                this.urls.push(url.expanded_url);
            }
        }
        // Extracting hashtags
        if (entities.hashtags) {
            for (const hashtag of entities.hashtags) {
                this.hashtags.push(hashtag.text);
            }
        }
    }
    /**
     * @returns A serializable JSON representation of `this` object.
     */
    toJSON() {
        return {
            hashtags: this.hashtags,
            mentionedUsers: this.mentionedUsers,
            urls: this.urls,
        };
    }
}
exports.TweetEntities = TweetEntities;
/**
 * The details of a single media content included in a tweet.
 *
 * @public
 */
class TweetMedia {
    /** The thumbnail URL for the video content of the tweet. */
    thumbnailUrl;
    /** The type of media. */
    type;
    /** The direct URL to the media. */
    url = '';
    /**
     * @param media - The raw media details.
     */
    constructor(media) {
        // If the media is a photo
        if (media.type == Media_2.RawMediaType.PHOTO) {
            this.type = Media_1.MediaType.PHOTO;
            this.url = media.media_url_https;
        }
        // If the media is a gif
        else if (media.type == Media_2.RawMediaType.GIF) {
            this.type = Media_1.MediaType.GIF;
            this.url = media.video_info?.variants[0].url;
        }
        // If the media is a video
        else {
            this.type = Media_1.MediaType.VIDEO;
            this.thumbnailUrl = media.media_url_https;
            /** The highest bitrate of all variants. */
            let highestRate = 0;
            /**
             * Selecting the URL of the video variant with the highest bitrate.
             */
            media.video_info?.variants.forEach((variant) => {
                if (variant.bitrate > highestRate) {
                    highestRate = variant.bitrate;
                    this.url = variant.url;
                }
            });
        }
    }
    /**
     * @returns A serializable JSON representation of `this` object.
     */
    toJSON() {
        return {
            thumbnailUrl: this.thumbnailUrl,
            type: this.type,
            url: this.url,
        };
    }
}
exports.TweetMedia = TweetMedia;
//# sourceMappingURL=Tweet.js.map