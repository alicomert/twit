"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetcherService = void 0;
const axios_1 = __importStar(require("axios"));
const cookiejar_1 = require("cookiejar");
const x_client_transaction_id_glacier_1 = require("x-client-transaction-id-glacier");
const Groups_1 = require("../../collections/Groups");
const Requests_1 = require("../../collections/Requests");
const Api_1 = require("../../enums/Api");
const Logging_1 = require("../../enums/Logging");
const FetchArgs_1 = require("../../models/args/FetchArgs");
const PostArgs_1 = require("../../models/args/PostArgs");
const AuthCredential_1 = require("../../models/auth/AuthCredential");
const AuthService_1 = require("../internal/AuthService");
const ErrorService_1 = require("../internal/ErrorService");
const LogService_1 = require("../internal/LogService");
/**
 * The base service that handles all HTTP requests.
 *
 * @public
 */
class FetcherService {
    /** The AuthService instance to use. */
    _auth;
    /** The delay/delay function to use (ms). */
    _delay;
    /** The service used to handle HTTP and API errors */
    _errorHandler;
    /** The max wait time for a response. */
    _timeout;
    /** The config object. */
    config;
    /**
     * @param config - The config object for configuring the Rettiwt instance.
     */
    constructor(config) {
        LogService_1.LogService.enabled = config.logging ?? false;
        this.config = config;
        this._delay = config.delay;
        this._errorHandler = config.errorHandler ?? new ErrorService_1.ErrorService();
        this._timeout = config.timeout ?? 0;
        this._auth = new AuthService_1.AuthService(config);
    }
    /**
     * Checks the authorization status based on the requested resource.
     *
     * @param resource - The requested resource.
     *
     * @throws An error if not authorized to access the requested resource.
     */
    _checkAuthorization(resource) {
        // Logging
        LogService_1.LogService.log(Logging_1.LogActions.AUTHORIZATION, { authenticated: this.config.userId != undefined });
        // Checking authorization status
        if (!Groups_1.AllowGuestAuthenticationGroup.includes(resource) && this.config.userId == undefined) {
            throw new Error(Api_1.ApiErrors.RESOURCE_NOT_ALLOWED);
        }
    }
    /**
     * Returns the AuthCredentials based on the type of key present.
     *
     * @returns The generated AuthCredential
     */
    async _getCredential() {
        if (this.config.apiKey) {
            // Logging
            LogService_1.LogService.log(Logging_1.LogActions.GET, { target: 'USER_CREDENTIAL' });
            return new AuthCredential_1.AuthCredential(AuthService_1.AuthService.decodeCookie(this.config.apiKey)
                .split(';')
                .map((item) => new cookiejar_1.Cookie(item)));
        }
        else {
            // Logging
            LogService_1.LogService.log(Logging_1.LogActions.GET, { target: 'NEW_GUEST_CREDENTIAL' });
            return this._auth.guest();
        }
    }
    /**
     * Generates the header for the transaction ID.
     *
     * @param method - The target method.
     * @param url - The target URL.
     *
     * @returns The header containing the transaction ID.
     */
    async _getTransactionHeader(method, url) {
        // Get the X homepage HTML document (using utility function)
        const document = await (0, x_client_transaction_id_glacier_1.handleXMigration)();
        // Create and initialize ClientTransaction instance
        const transaction = await x_client_transaction_id_glacier_1.ClientTransaction.create(document);
        // Getting the URL path excluding all params
        const path = new URL(url).pathname.split('?')[0].trim();
        // Generating the transaction ID
        const tid = await transaction.generateTransactionId(method.toUpperCase(), path);
        return {
            /* eslint-disable @typescript-eslint/naming-convention */
            'x-client-transaction-id': tid,
            /* eslint-enable @typescript-eslint/naming-convention */
        };
    }
    /**
     * Validates the given args against the given resource.
     *
     * @param resource - The resource against which validation is to be done.
     * @param args - The args to be validated.
     *
     * @returns The validated args.
     */
    _validateArgs(resource, args) {
        if (Groups_1.FetchResourcesGroup.includes(resource)) {
            // Logging
            LogService_1.LogService.log(Logging_1.LogActions.VALIDATE, { target: 'FETCH_ARGS' });
            return new FetchArgs_1.FetchArgs(args);
        }
        else if (Groups_1.PostResourcesGroup.includes(resource)) {
            // Logging
            LogService_1.LogService.log(Logging_1.LogActions.VALIDATE, { target: 'POST_ARGS' });
            return new PostArgs_1.PostArgs(args);
        }
    }
    /**
     * Introduces a delay using the configured delay/delay function.
     */
    async _wait() {
        // If no delay is set, skip
        if (this._delay == undefined) {
            return;
        }
        /** The delay (in ms) to use. */
        let delay = 0;
        // Getting the delay
        if (this._delay && typeof this._delay == 'number') {
            delay = this._delay;
        }
        else if (this._delay && typeof this._delay == 'function') {
            delay = await this._delay();
        }
        // Awaiting for the delay time
        await new Promise((resolve) => setTimeout(resolve, delay));
    }
    /**
     * Makes an HTTP request according to the given parameters.
     *
     * @param resource - The requested resource.
     * @param config - The request configuration.
     *
     * @typeParam T - The type of the returned response data.
     *
     * @returns The raw data response received.
     *
     * @example
     *
     * #### Fetching the raw details of a single user, using their username
     * ```ts
     * import { FetcherService, EResourceType } from 'rettiwt-api';
     *
     * // Creating a new FetcherService instance using the given 'API_KEY'
     * const fetcher = new FetcherService({ apiKey: API_KEY });
     *
     * // Fetching the details of the User with username 'user1'
     * fetcher.request(EResourceType.USER_DETAILS_BY_USERNAME, { id: 'user1' })
     * .then(res => {
     * 	console.log(res);
     * })
     * .catch(err => {
     * 	console.log(err);
     * });
     * ```
     */
    async request(resource, args) {
        /** The current retry number. */
        let retry = 0;
        /** The error, if any. */
        let error = undefined;
        // Logging
        LogService_1.LogService.log(Logging_1.LogActions.REQUEST, { resource: resource, args: args });
        // Checking authorization for the requested resource
        this._checkAuthorization(resource);
        // Validating args
        args = this._validateArgs(resource, args);
        // Getting credentials from key
        const cred = await this._getCredential();
        // Getting request configuration
        const config = Requests_1.Requests[resource](args);
        // Setting additional request parameters
        config.headers = {
            ...config.headers,
            ...cred.toHeader(),
            ...this.config.headers,
        };
        config.httpAgent = this.config.httpsAgent;
        config.httpsAgent = this.config.httpsAgent;
        config.timeout = this._timeout;
        // Using retries for error 404
        do {
            // Sending the request
            try {
                // Getting and appending transaction information
                config.headers = {
                    ...config.headers,
                    ...(await this._getTransactionHeader(config.method ?? '', config.url ?? '')),
                };
                // Introducing a delay
                await this._wait();
                // Returning the reponse body
                return (await (0, axios_1.default)(config)).data;
            }
            catch (err) {
                // If it's an error 404, retry
                if ((0, axios_1.isAxiosError)(err) && err.status === 404) {
                    error = err;
                    continue;
                }
                // Else, delegate error handling
                else {
                    this._errorHandler.handle(err);
                    throw err;
                }
            }
            finally {
                // Incrementing the number of retries done
                retry++;
            }
        } while (retry < this.config.maxRetries);
        /** If request not successful even after retries, throw the error */
        throw error;
    }
}
exports.FetcherService = FetcherService;
//# sourceMappingURL=FetcherService.js.map